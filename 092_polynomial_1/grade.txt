Grading at 11/04/2024:20:52:07.452453
For commit ID d0514147f126c8ea4d689df5d58c7139e39fced8
Grading at Mon Nov  4 03:52:07 PM EST 2024
Compiling your code with our test main
In file included from testmain.cpp:4:
poly.hpp: In constructor ‘Polynomial<NumT>::Polynomial()’:
poly.hpp:11:23: error: extended initializer lists only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   11 |   Polynomial() : terms{{NumT(), 0}} {}
      |                       ^
poly.hpp: In member function ‘Polynomial<NumT> Polynomial<NumT>::operator-() const’:
poly.hpp:39:14: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
   39 |   for (const auto & term : terms) {
      |              ^~~~
      |              ----
poly.hpp:39:21: error: ISO C++ forbids declaration of ‘term’ with no type [-fpermissive]
   39 |   for (const auto & term : terms) {
      |                     ^~~~
poly.hpp:39:28: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   39 |   for (const auto & term : terms) {
      |                            ^~~~~
poly.hpp:40:26: error: request for member ‘first’ in ‘term’, which is of non-class type ‘const int’
   40 |     result.addTerm(-term.first, term.second);
      |                          ^~~~~
poly.hpp:40:38: error: request for member ‘second’ in ‘term’, which is of non-class type ‘const int’
   40 |     result.addTerm(-term.first, term.second);
      |                                      ^~~~~~
poly.hpp: In member function ‘Polynomial<NumT> Polynomial<NumT>::operator*(const NumT&) const’:
poly.hpp:55:14: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
   55 |   for (const auto & term : terms) {
      |              ^~~~
      |              ----
poly.hpp:55:21: error: ISO C++ forbids declaration of ‘term’ with no type [-fpermissive]
   55 |   for (const auto & term : terms) {
      |                     ^~~~
poly.hpp:55:28: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   55 |   for (const auto & term : terms) {
      |                            ^~~~~
poly.hpp:56:25: error: request for member ‘first’ in ‘term’, which is of non-class type ‘const int’
   56 |     result.addTerm(term.first * n, term.second);
      |                         ^~~~~
poly.hpp:56:41: error: request for member ‘second’ in ‘term’, which is of non-class type ‘const int’
   56 |     result.addTerm(term.first * n, term.second);
      |                                         ^~~~~~
poly.hpp: In member function ‘Polynomial<NumT> Polynomial<NumT>::operator*(const Polynomial<NumT>&) const’:
poly.hpp:64:14: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
   64 |   for (const auto & lhsTerm : terms) {
      |              ^~~~
      |              ----
poly.hpp:64:21: error: ISO C++ forbids declaration of ‘lhsTerm’ with no type [-fpermissive]
   64 |   for (const auto & lhsTerm : terms) {
      |                     ^~~~~~~
poly.hpp:64:31: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   64 |   for (const auto & lhsTerm : terms) {
      |                               ^~~~~
poly.hpp:65:16: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
   65 |     for (const auto & rhsTerm : rhs.terms) {
      |                ^~~~
      |                ----
poly.hpp:65:23: error: ISO C++ forbids declaration of ‘rhsTerm’ with no type [-fpermissive]
   65 |     for (const auto & rhsTerm : rhs.terms) {
      |                       ^~~~~~~
poly.hpp:65:33: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   65 |     for (const auto & rhsTerm : rhs.terms) {
      |                                 ^~~
poly.hpp:66:30: error: request for member ‘first’ in ‘lhsTerm’, which is of non-class type ‘const int’
   66 |       result.addTerm(lhsTerm.first * rhsTerm.first, lhsTerm.second + rhsTerm.second);
      |                              ^~~~~
poly.hpp:66:46: error: request for member ‘first’ in ‘rhsTerm’, which is of non-class type ‘const int’
   66 |       result.addTerm(lhsTerm.first * rhsTerm.first, lhsTerm.second + rhsTerm.second);
      |                                              ^~~~~
poly.hpp:66:61: error: request for member ‘second’ in ‘lhsTerm’, which is of non-class type ‘const int’
   66 |       result.addTerm(lhsTerm.first * rhsTerm.first, lhsTerm.second + rhsTerm.second);
      |                                                             ^~~~~~
poly.hpp:66:78: error: request for member ‘second’ in ‘rhsTerm’, which is of non-class type ‘const int’
   66 |       result.addTerm(lhsTerm.first * rhsTerm.first, lhsTerm.second + rhsTerm.second);
      |                                                                              ^~~~~~
poly.hpp: In member function ‘void Polynomial<NumT>::addTerm(const NumT&, unsigned int)’:
poly.hpp:84:8: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
   84 |   for (auto & term : terms) {
      |        ^~~~
      |        ----
poly.hpp:84:15: error: ISO C++ forbids declaration of ‘term’ with no type [-fpermissive]
   84 |   for (auto & term : terms) {
      |               ^~~~
poly.hpp:84:22: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   84 |   for (auto & term : terms) {
      |                      ^~~~~
poly.hpp:85:14: error: request for member ‘second’ in ‘term’, which is of non-class type ‘int’
   85 |     if (term.second == p) {
      |              ^~~~~~
poly.hpp:86:12: error: request for member ‘first’ in ‘term’, which is of non-class type ‘int’
   86 |       term.first += c;
      |            ^~~~~
poly.hpp: In member function ‘Polynomial<NumT>& Polynomial<NumT>::operator+=(const Polynomial<NumT>&)’:
poly.hpp:95:14: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
   95 |   for (const auto & term : rhs.terms) {
      |              ^~~~
      |              ----
poly.hpp:95:21: error: ISO C++ forbids declaration of ‘term’ with no type [-fpermissive]
   95 |   for (const auto & term : rhs.terms) {
      |                     ^~~~
poly.hpp:95:28: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   95 |   for (const auto & term : rhs.terms) {
      |                            ^~~
poly.hpp:96:18: error: request for member ‘first’ in ‘term’, which is of non-class type ‘const int’
   96 |     addTerm(term.first, term.second);
      |                  ^~~~~
poly.hpp:96:30: error: request for member ‘second’ in ‘term’, which is of non-class type ‘const int’
   96 |     addTerm(term.first, term.second);
      |                              ^~~~~~
poly.hpp: In member function ‘Polynomial<NumT>& Polynomial<NumT>::operator-=(const Polynomial<NumT>&)’:
poly.hpp:103:14: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
  103 |   for (const auto & term : rhs.terms) {
      |              ^~~~
      |              ----
poly.hpp:103:21: error: ISO C++ forbids declaration of ‘term’ with no type [-fpermissive]
  103 |   for (const auto & term : rhs.terms) {
      |                     ^~~~
poly.hpp:103:28: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
  103 |   for (const auto & term : rhs.terms) {
      |                            ^~~
poly.hpp:104:19: error: request for member ‘first’ in ‘term’, which is of non-class type ‘const int’
  104 |     addTerm(-term.first, term.second);
      |                   ^~~~~
poly.hpp:104:31: error: request for member ‘second’ in ‘term’, which is of non-class type ‘const int’
  104 |     addTerm(-term.first, term.second);
      |                               ^~~~~~
poly.hpp: In member function ‘Polynomial<NumT>& Polynomial<NumT>::operator*=(const NumT&)’:
poly.hpp:117:8: error: ‘auto’ changes meaning in C++11; please remove it [-Werror=c++11-compat]
  117 |   for (auto & term : terms) {
      |        ^~~~
      |        ----
poly.hpp:117:15: error: ISO C++ forbids declaration of ‘term’ with no type [-fpermissive]
  117 |   for (auto & term : terms) {
      |               ^~~~
poly.hpp:117:22: error: range-based ‘for’ loops only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
  117 |   for (auto & term : terms) {
      |                      ^~~~~
poly.hpp:118:10: error: request for member ‘first’ in ‘term’, which is of non-class type ‘int’
  118 |     term.first *= rhs;
      |          ^~~~~
poly.hpp: In instantiation of ‘Polynomial<NumT>::Polynomial() [with NumT = int]’:
testmain.cpp:7:19:   required from here
poly.hpp:11:18: error: extended initializer lists only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   11 |   Polynomial() : terms{{NumT(), 0}} {}
      |                  ^~~~~~~~~~~~~~~~~~
poly.hpp:11:18: error: extended initializer lists only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
poly.hpp:11:18: error: no matching function for call to ‘std::vector<std::pair<int, unsigned int>, std::allocator<std::pair<int, unsigned int> > >::vector(<brace-enclosed initializer list>)’
In file included from /usr/include/c++/11/vector:67,
                 from poly.hpp:3,
                 from testmain.cpp:4:
/usr/include/c++/11/bits/stl_vector.h:662:9: note: candidate: ‘template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&) [with _InputIterator = _InputIterator; _Tp = std::pair<int, unsigned int>; _Alloc = std::allocator<std::pair<int, unsigned int> >]’
  662 |         vector(_InputIterator __first, _InputIterator __last,
      |         ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:662:9: note:   template argument deduction/substitution failed:
In file included from testmain.cpp:4:
poly.hpp:11:18: note:   candidate expects 3 arguments, 1 provided
   11 |   Polynomial() : terms{{NumT(), 0}} {}
      |                  ^~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/vector:67,
                 from poly.hpp:3,
                 from testmain.cpp:4:
/usr/include/c++/11/bits/stl_vector.h:553:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = std::pair<int, unsigned int>; _Alloc = std::allocator<std::pair<int, unsigned int> >]’
  553 |       vector(const vector& __x)
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:553:28: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const std::vector<std::pair<int, unsigned int>, std::allocator<std::pair<int, unsigned int> > >&’
  553 |       vector(const vector& __x)
      |              ~~~~~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:536:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = std::pair<int, unsigned int>; _Alloc = std::allocator<std::pair<int, unsigned int> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = std::pair<int, unsigned int>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<std::pair<int, unsigned int> >]’
  536 |       vector(size_type __n, const value_type& __value = value_type(),
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:536:24: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<int, unsigned int>, std::allocator<std::pair<int, unsigned int> > >::size_type’ {aka ‘long unsigned int’}
  536 |       vector(size_type __n, const value_type& __value = value_type(),
      |              ~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:497:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = std::pair<int, unsigned int>; _Alloc = std::allocator<std::pair<int, unsigned int> >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<std::pair<int, unsigned int> >]’
  497 |       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:497:36: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const allocator_type&’ {aka ‘const std::allocator<std::pair<int, unsigned int> >&’}
  497 |       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:489:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = std::pair<int, unsigned int>; _Alloc = std::allocator<std::pair<int, unsigned int> >]’
  489 |       vector() { }
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:489:7: note:   candidate expects 0 arguments, 1 provided
In file included from testmain.cpp:4:
poly.hpp: In instantiation of ‘void Polynomial<NumT>::addTerm(const NumT&, unsigned int) [with NumT = int]’:
testmain.cpp:10:13:   required from here
poly.hpp:84:3: error: invalid initialization of reference of type ‘int&’ from expression of type ‘std::pair<int, unsigned int>’
   84 |   for (auto & term : terms) {
      |   ^~~
poly.hpp:84:15: error: loop variable ‘term’ of type ‘int&’ binds to a temporary constructed from type ‘std::pair<int, unsigned int>’ [-Werror=range-loop-construct]
   84 |   for (auto & term : terms) {
      |               ^~~~
poly.hpp:84:15: note: use non-reference type ‘int’ to make the copy explicit or ‘const std::pair<int, unsigned int>&’ to prevent copying
poly.hpp:90:9: error: ‘class std::vector<std::pair<int, unsigned int>, std::allocator<std::pair<int, unsigned int> > >’ has no member named ‘emplace_back’
   90 |   terms.emplace_back(c, p);
      |   ~~~~~~^~~~~~~~~~~~
poly.hpp: In instantiation of ‘Polynomial<NumT> Polynomial<NumT>::operator-() const [with NumT = int]’:
testmain.cpp:15:28:   required from here
poly.hpp:39:3: error: invalid initialization of reference of type ‘const int&’ from expression of type ‘const std::pair<int, unsigned int>’
   39 |   for (const auto & term : terms) {
      |   ^~~
poly.hpp:39:21: error: loop variable ‘term’ of type ‘const int&’ binds to a temporary constructed from type ‘const std::pair<int, unsigned int>’ [-Werror=range-loop-construct]
   39 |   for (const auto & term : terms) {
      |                     ^~~~
poly.hpp:39:21: note: use non-reference type ‘const int’ to make the copy explicit or ‘const std::pair<int, unsigned int>&’ to prevent copying
poly.hpp: In instantiation of ‘Polynomial<NumT> Polynomial<NumT>::operator*(const Polynomial<NumT>&) const [with NumT = int]’:
testmain.cpp:22:36:   required from here
poly.hpp:64:3: error: invalid initialization of reference of type ‘const int&’ from expression of type ‘const std::pair<int, unsigned int>’
   64 |   for (const auto & lhsTerm : terms) {
      |   ^~~
poly.hpp:64:21: error: loop variable ‘lhsTerm’ of type ‘const int&’ binds to a temporary constructed from type ‘const std::pair<int, unsigned int>’ [-Werror=range-loop-construct]
   64 |   for (const auto & lhsTerm : terms) {
      |                     ^~~~~~~
poly.hpp:64:21: note: use non-reference type ‘const int’ to make the copy explicit or ‘const std::pair<int, unsigned int>&’ to prevent copying
poly.hpp:65:5: error: invalid initialization of reference of type ‘const int&’ from expression of type ‘const std::pair<int, unsigned int>’
   65 |     for (const auto & rhsTerm : rhs.terms) {
      |     ^~~
poly.hpp:65:23: error: loop variable ‘rhsTerm’ of type ‘const int&’ binds to a temporary constructed from type ‘const std::pair<int, unsigned int>’ [-Werror=range-loop-construct]
   65 |     for (const auto & rhsTerm : rhs.terms) {
      |                       ^~~~~~~
poly.hpp:65:23: note: use non-reference type ‘const int’ to make the copy explicit or ‘const std::pair<int, unsigned int>&’ to prevent copying
poly.hpp: In instantiation of ‘Polynomial<NumT>& Polynomial<NumT>::operator+=(const Polynomial<NumT>&) [with NumT = int]’:
testmain.cpp:37:9:   required from here
poly.hpp:95:3: error: invalid initialization of reference of type ‘const int&’ from expression of type ‘const std::pair<int, unsigned int>’
   95 |   for (const auto & term : rhs.terms) {
      |   ^~~
poly.hpp:95:21: error: loop variable ‘term’ of type ‘const int&’ binds to a temporary constructed from type ‘const std::pair<int, unsigned int>’ [-Werror=range-loop-construct]
   95 |   for (const auto & term : rhs.terms) {
      |                     ^~~~
poly.hpp:95:21: note: use non-reference type ‘const int’ to make the copy explicit or ‘const std::pair<int, unsigned int>&’ to prevent copying
poly.hpp: In instantiation of ‘Polynomial<NumT>& Polynomial<NumT>::operator-=(const Polynomial<NumT>&) [with NumT = int]’:
testmain.cpp:41:9:   required from here
poly.hpp:103:3: error: invalid initialization of reference of type ‘const int&’ from expression of type ‘const std::pair<int, unsigned int>’
  103 |   for (const auto & term : rhs.terms) {
      |   ^~~
poly.hpp:103:21: error: loop variable ‘term’ of type ‘const int&’ binds to a temporary constructed from type ‘const std::pair<int, unsigned int>’ [-Werror=range-loop-construct]
  103 |   for (const auto & term : rhs.terms) {
      |                     ^~~~
poly.hpp:103:21: note: use non-reference type ‘const int’ to make the copy explicit or ‘const std::pair<int, unsigned int>&’ to prevent copying
poly.hpp: In instantiation of ‘Polynomial<NumT>& Polynomial<NumT>::operator*=(const NumT&) [with NumT = int]’:
testmain.cpp:43:9:   required from here
poly.hpp:117:3: error: invalid initialization of reference of type ‘int&’ from expression of type ‘std::pair<int, unsigned int>’
  117 |   for (auto & term : terms) {
      |   ^~~
poly.hpp:117:15: error: loop variable ‘term’ of type ‘int&’ binds to a temporary constructed from type ‘std::pair<int, unsigned int>’ [-Werror=range-loop-construct]
  117 |   for (auto & term : terms) {
      |               ^~~~
poly.hpp:117:15: note: use non-reference type ‘int’ to make the copy explicit or ‘const std::pair<int, unsigned int>&’ to prevent copying
poly.hpp: In instantiation of ‘Polynomial<NumT>::Polynomial() [with NumT = double]’:
testmain.cpp:74:22:   required from here
poly.hpp:11:18: error: extended initializer lists only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   11 |   Polynomial() : terms{{NumT(), 0}} {}
      |                  ^~~~~~~~~~~~~~~~~~
poly.hpp:11:18: error: extended initializer lists only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
poly.hpp:11:18: error: no matching function for call to ‘std::vector<std::pair<double, unsigned int>, std::allocator<std::pair<double, unsigned int> > >::vector(<brace-enclosed initializer list>)’
In file included from /usr/include/c++/11/vector:67,
                 from poly.hpp:3,
                 from testmain.cpp:4:
/usr/include/c++/11/bits/stl_vector.h:662:9: note: candidate: ‘template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&) [with _InputIterator = _InputIterator; _Tp = std::pair<double, unsigned int>; _Alloc = std::allocator<std::pair<double, unsigned int> >]’
  662 |         vector(_InputIterator __first, _InputIterator __last,
      |         ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:662:9: note:   template argument deduction/substitution failed:
In file included from testmain.cpp:4:
poly.hpp:11:18: note:   candidate expects 3 arguments, 1 provided
   11 |   Polynomial() : terms{{NumT(), 0}} {}
      |                  ^~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/vector:67,
                 from poly.hpp:3,
                 from testmain.cpp:4:
/usr/include/c++/11/bits/stl_vector.h:553:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = std::pair<double, unsigned int>; _Alloc = std::allocator<std::pair<double, unsigned int> >]’
  553 |       vector(const vector& __x)
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:553:28: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const std::vector<std::pair<double, unsigned int>, std::allocator<std::pair<double, unsigned int> > >&’
  553 |       vector(const vector& __x)
      |              ~~~~~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:536:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = std::pair<double, unsigned int>; _Alloc = std::allocator<std::pair<double, unsigned int> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = std::pair<double, unsigned int>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<std::pair<double, unsigned int> >]’
  536 |       vector(size_type __n, const value_type& __value = value_type(),
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:536:24: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<double, unsigned int>, std::allocator<std::pair<double, unsigned int> > >::size_type’ {aka ‘long unsigned int’}
  536 |       vector(size_type __n, const value_type& __value = value_type(),
      |              ~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:497:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = std::pair<double, unsigned int>; _Alloc = std::allocator<std::pair<double, unsigned int> >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<std::pair<double, unsigned int> >]’
  497 |       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:497:36: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const allocator_type&’ {aka ‘const std::allocator<std::pair<double, unsigned int> >&’}
  497 |       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:489:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = std::pair<double, unsigned int>; _Alloc = std::allocator<std::pair<double, unsigned int> >]’
  489 |       vector() { }
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:489:7: note:   candidate expects 0 arguments, 1 provided
In file included from testmain.cpp:4:
poly.hpp: In instantiation of ‘void Polynomial<NumT>::addTerm(const NumT&, unsigned int) [with NumT = double]’:
testmain.cpp:75:14:   required from here
poly.hpp:84:3: error: invalid initialization of reference of type ‘int&’ from expression of type ‘std::pair<double, unsigned int>’
   84 |   for (auto & term : terms) {
      |   ^~~
poly.hpp:84:15: error: loop variable ‘term’ of type ‘int&’ binds to a temporary constructed from type ‘std::pair<double, unsigned int>’ [-Werror=range-loop-construct]
   84 |   for (auto & term : terms) {
      |               ^~~~
poly.hpp:84:15: note: use non-reference type ‘int’ to make the copy explicit or ‘const std::pair<double, unsigned int>&’ to prevent copying
poly.hpp:90:9: error: ‘class std::vector<std::pair<double, unsigned int>, std::allocator<std::pair<double, unsigned int> > >’ has no member named ‘emplace_back’
   90 |   terms.emplace_back(c, p);
      |   ~~~~~~^~~~~~~~~~~~
poly.hpp: In instantiation of ‘Polynomial<NumT>& Polynomial<NumT>::operator*=(const NumT&) [with NumT = double]’:
testmain.cpp:79:11:   required from here
poly.hpp:117:3: error: invalid initialization of reference of type ‘int&’ from expression of type ‘std::pair<double, unsigned int>’
  117 |   for (auto & term : terms) {
      |   ^~~
poly.hpp:117:15: error: loop variable ‘term’ of type ‘int&’ binds to a temporary constructed from type ‘std::pair<double, unsigned int>’ [-Werror=range-loop-construct]
  117 |   for (auto & term : terms) {
      |               ^~~~
poly.hpp:117:15: note: use non-reference type ‘int’ to make the copy explicit or ‘const std::pair<double, unsigned int>&’ to prevent copying
poly.hpp: In instantiation of ‘Polynomial<NumT> Polynomial<NumT>::operator*(const NumT&) const [with NumT = double]’:
testmain.cpp:81:42:   required from here
poly.hpp:55:3: error: invalid initialization of reference of type ‘const int&’ from expression of type ‘const std::pair<double, unsigned int>’
   55 |   for (const auto & term : terms) {
      |   ^~~
poly.hpp:55:21: error: loop variable ‘term’ of type ‘const int&’ binds to a temporary constructed from type ‘const std::pair<double, unsigned int>’ [-Werror=range-loop-construct]
   55 |   for (const auto & term : terms) {
      |                     ^~~~
poly.hpp:55:21: note: use non-reference type ‘const int’ to make the copy explicit or ‘const std::pair<double, unsigned int>&’ to prevent copying
poly.hpp: In instantiation of ‘Polynomial<NumT>::Polynomial() [with NumT = std::complex<double>]’:
testmain.cpp:82:37:   required from here
poly.hpp:11:18: error: extended initializer lists only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
   11 |   Polynomial() : terms{{NumT(), 0}} {}
      |                  ^~~~~~~~~~~~~~~~~~
poly.hpp:11:18: error: extended initializer lists only available with ‘-std=c++11’ or ‘-std=gnu++11’ [-Werror]
poly.hpp:11:18: error: no matching function for call to ‘std::vector<std::pair<std::complex<double>, unsigned int>, std::allocator<std::pair<std::complex<double>, unsigned int> > >::vector(<brace-enclosed initializer list>)’
In file included from /usr/include/c++/11/vector:67,
                 from poly.hpp:3,
                 from testmain.cpp:4:
/usr/include/c++/11/bits/stl_vector.h:662:9: note: candidate: ‘template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&) [with _InputIterator = _InputIterator; _Tp = std::pair<std::complex<double>, unsigned int>; _Alloc = std::allocator<std::pair<std::complex<double>, unsigned int> >]’
  662 |         vector(_InputIterator __first, _InputIterator __last,
      |         ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:662:9: note:   template argument deduction/substitution failed:
In file included from testmain.cpp:4:
poly.hpp:11:18: note:   candidate expects 3 arguments, 1 provided
   11 |   Polynomial() : terms{{NumT(), 0}} {}
      |                  ^~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/11/vector:67,
                 from poly.hpp:3,
                 from testmain.cpp:4:
/usr/include/c++/11/bits/stl_vector.h:553:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = std::pair<std::complex<double>, unsigned int>; _Alloc = std::allocator<std::pair<std::complex<double>, unsigned int> >]’
  553 |       vector(const vector& __x)
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:553:28: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const std::vector<std::pair<std::complex<double>, unsigned int>, std::allocator<std::pair<std::complex<double>, unsigned int> > >&’
  553 |       vector(const vector& __x)
      |              ~~~~~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:536:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = std::pair<std::complex<double>, unsigned int>; _Alloc = std::allocator<std::pair<std::complex<double>, unsigned int> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = std::pair<std::complex<double>, unsigned int>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<std::pair<std::complex<double>, unsigned int> >]’
  536 |       vector(size_type __n, const value_type& __value = value_type(),
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:536:24: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::complex<double>, unsigned int>, std::allocator<std::pair<std::complex<double>, unsigned int> > >::size_type’ {aka ‘long unsigned int’}
  536 |       vector(size_type __n, const value_type& __value = value_type(),
      |              ~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:497:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = std::pair<std::complex<double>, unsigned int>; _Alloc = std::allocator<std::pair<std::complex<double>, unsigned int> >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<std::pair<std::complex<double>, unsigned int> >]’
  497 |       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:497:36: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const allocator_type&’ {aka ‘const std::allocator<std::pair<std::complex<double>, unsigned int> >&’}
  497 |       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      |              ~~~~~~~~~~~~~~~~~~~~~~^~~
/usr/include/c++/11/bits/stl_vector.h:489:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = std::pair<std::complex<double>, unsigned int>; _Alloc = std::allocator<std::pair<std::complex<double>, unsigned int> >]’
  489 |       vector() { }
      |       ^~~~~~
/usr/include/c++/11/bits/stl_vector.h:489:7: note:   candidate expects 0 arguments, 1 provided
In file included from testmain.cpp:4:
poly.hpp: In instantiation of ‘void Polynomial<NumT>::addTerm(const NumT&, unsigned int) [with NumT = std::complex<double>]’:
testmain.cpp:83:14:   required from here
poly.hpp:84:3: error: invalid initialization of reference of type ‘int&’ from expression of type ‘std::pair<std::complex<double>, unsigned int>’
   84 |   for (auto & term : terms) {
      |   ^~~
poly.hpp:84:15: error: loop variable ‘term’ of type ‘int&’ binds to a temporary constructed from type ‘std::pair<std::complex<double>, unsigned int>’ [-Werror=range-loop-construct]
   84 |   for (auto & term : terms) {
      |               ^~~~
poly.hpp:84:15: note: use non-reference type ‘int’ to make the copy explicit or ‘const std::pair<std::complex<double>, unsigned int>&’ to prevent copying
poly.hpp:90:9: error: ‘class std::vector<std::pair<std::complex<double>, unsigned int>, std::allocator<std::pair<std::complex<double>, unsigned int> > >’ has no member named ‘emplace_back’
   90 |   terms.emplace_back(c, p);
      |   ~~~~~~^~~~~~~~~~~~
cc1plus: all warnings being treated as errors
g++ failed

Overall Grade: FAILED
